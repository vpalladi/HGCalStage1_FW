from __future__ import print_function
import time, os

from SmartOpen import SmartOpen
from DepFileParser import DepFileParser
from CommandLineParser import CommandLineParser
from Pathmaker import Pathmaker

#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class ModelsimScriptWriter( object ):
  def __init__( self , aCommandLineArgs , aPathmaker ):
    self.CommandLineArgs = aCommandLineArgs
    self.Pathmaker = aPathmaker
 
  def write( self , aScriptVariables , aComponentPaths , aCommandList , aLibs, aMaps ):

    with SmartOpen( self.CommandLineArgs.output ) as write:
      write("# Autogenerated project build script")
      write( time.strftime("# %c") )
      write( )

      for setup in aCommandList["setup"]:
        write( "source {0}".format( setup.FilePath ) )
        
      write("vlib work")
      
      for lib in aLibs:
        write("vlib {0}".format( lib ))
      
      for ma in aMaps:
        write("vmap {0} {1}".format( ma[0], ma[1] ))
        write("vcom -work {0} -refresh -force_refresh".format( ma[0] ))

      for src in reversed( aCommandList["src"] ):
        if src.Include:
          
          lPath , lBasename = os.path.split( src.FilePath )
          lName, lExt = os.path.splitext( lBasename  )
          lMap = src.Map

          if lExt == ".xco":
            file = os.path.abspath( os.path.join( lPath , lName + ".vhd" ) )
          elif lExt == ".xci":
            # Hack required. The Vivado generated hdl files sometimes have 'sim' in their path, sometimes don't
            file = None
            lIpPath = os.path.abspath( os.path.join( os.path.split( self.CommandLineArgs.output )[0] , "top/top.srcs/sources_1/ip") )
            for d in ["","sim"]:
              lPathToIp = os.path.join(lIpPath,lName,d,lName+".vhd")
              if not os.path.exists(os.path.join(lPathToIp)): continue

              file = lPathToIp
              break

            if file is None:
              raise IOError('No simulation source found for core '+lBasename)

            # file = os.path.abspath( os.path.join( os.path.split( self.CommandLineArgs.output )[0] , "top/top.srcs/sources_1/ip" , lName, "sim" , lName + ".vhd" ) )
            print(file)
          else:
            file = src.FilePath
            
          if os.path.splitext(file)[1] == ".vhd":
            if src.Vhdl2008:
              cmd = "vcom -2008"
            else:
              cmd = "vcom"
          elif os.path.splitext(file)[1] == ".v":
            cmd = "vlog"
          
          elif lMap != None:
            continue

          else:
            #if os.path.splitext(file)[1] != ".ucf":
              #raise SystemExit("Unknown source file type in Modelsim build: {0}".format(src.FilePath) )
            print( "# IGNORING unknown source file type in Modelsim build: {0}".format(src.FilePath) )
            continue
         
          if src.Lib:
            cmd = "{0} -work {1}".format(cmd, src.Lib)

        write( "{0} {1}".format( cmd , file ) )
          
    # Hacky hack: add newly generated libraries to modelsim.ini
    lSimLibDirectory = os.path.abspath( os.path.join( os.path.split( self.CommandLineArgs.output )[0] , "top/top.sim/sim_1/behav/msim") )
    lSimLibs = next(os.walk(lSimLibDirectory))[1]

    print ('found libs',lSimLibs)

    print("Adapting modelsim.ini")
    import ConfigParser
    
    lModelsimIni = ConfigParser.RawConfigParser()
    lModelsimIni.read("modelsim.ini")
    print(lModelsimIni.sections())
    for l in lSimLibs:
      lModelsimIni.set("Library",l,os.path.join(lSimLibDirectory,l))

    os.rename("modelsim.ini","modelsim.ini.bak")
    with SmartOpen( "modelsim.ini" ) as newIni:
      lModelsimIni.write(newIni.file)


#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
